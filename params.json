{"name":"Radial Basis Interpolation","tagline":"Interpolating Scattered Data in N-Dimensions","body":"## About the USRA* Project\r\nThis project explores the use of Radial Basis Functions (RBFs) in the interpolation of scattered data in N-dimensions. It was completed Summer 2014 by Jesse Bettencourt as an NSERC-USRA student under the supervision of Dr. Kevlahan in the Department of Mathematics and Statistics at McMaster University, Hamilton, Ontario, Canada. \r\n\r\n*[Undergraduate Student Research Awards (USRA)](http://www.nserc-crsng.gc.ca/students-etudiants/ug-pc/usra-brpc_eng.asp) are granted by the Natural Sciences and Engineering Research Council of Canada to 'stimulate interest in research in the natural sciences and engineering' and to encourage graduate studies and the pursuit of research careers in these fields.\r\n\r\n## About this Repository \r\nThis repository contains resources and working documents associated with the project. The early stages of the project focused on reviewing the published literature on RBF interpolation. This was summarized in a presentation given at the [Canadian Undergraduate Mathematics Conference (CUMC) 2014 at Carelton University][1]. The pdf, LaTeX, and figures as well as the python script to generate figures from this presentation can be found in the [CUMC Presentation][2] folder. Following the presentation, the project shifted focus to demonstrating the [SciPy implementation of RBF interpolation][3]. The [Interpolation Demonstration][4] folder contains the python files associated with this exploration. Of note, the file [SphericalHarmonicInterpolation.py][5] demonstrates how RBFs can be used to interpolate spherical harmonics given data sites and measurements on the surface of a sphere. This folder also contains iPython notebooks from early experimentation with SciPy's RBF and a Mathematica notebook from preliminary assessment of Mathematica implementation of RBF interpolation. \r\n\r\n#Radial Basis Function Interpolation\r\n##What is interpolation?\r\nGiven a set of **measurements** $\\{f_i\\}_{i=1}^N$ taken at corresponding **data sites** $\\{x_i\\}_{i=1}^N$ we want to find an **interpolation function** $s(x)$ that informs us on our system at locations different from our data sites. \r\n\r\n![enter image description here][6]\r\n\r\nFurther, we want our function, $s(x)$ to satisfy what's called the **interpolation condition** which is that we want to our interpolation function to exactly match our measurements at our data sites. \r\n> Interpolation Condition: \r\n\\begin{equation*}\r\ns(x_i)=f_i \r\n\\end{equation*}\r\n$\\forall i\\in\\{0 ... N \\}$\r\n\r\n\r\nThis is how interpolation differs from approximation, where approximation does not necessitate that our function exactly equals our measurements at the data sites. This can be achieved through different methods, e.g., Least Squares approximation. Sometimes, when accuracy at data sites is not necessary, approximation is preferred over interpolation because it can provide a 'nicer' function which could better illustrate the relationship among the data sites and measurements. For instance, approximation is heavily utilized in experimental science where measurements can contain a measurement error associated with experimental procedures. In this environment, the interpolation condition may be undesirable because it forces the interpolation to match exactly with potential measurement error, where approximation may alleviate error influence and illustrate measured correlations better. \r\n\r\n![enter image description here][7]\r\n\r\nFor the purposes of this project, we focus on interpolation only. \r\n\r\n##Interpolation Assumption\r\nMany interpolation methods rely on the convenient assumption that our interpolation function, $s(x)$, can be found through a linear combination of **basis functions**, $\\psi_i(x)$.\r\n\r\n>Linear Combination Assumption: \r\n\\begin{equation*}\r\ns(x)=\\sum_{i=1}^N \\lambda_i \\psi_i\r\n\\end{equation*}\r\n\r\n\r\nThis assumption is convenient as it allows us to utilize solving methods for systems of linear equations from linear algebra to find our interpolation function. As such, we can express our interpolation problem as a linear system.\r\n\r\n>Interpolation as Linear System: \r\n\\begin{equation*}\r\nA\\boldsymbol{\\lambda}=\\boldsymbol{f}\r\n\\end{equation*}\r\n\r\n\r\nWhere $\\boldsymbol{f}$ is the vector of datasite measurements $\\left[ f_1, ..., f_N \\right]^T$ and $\\boldsymbol{\\lambda}$ is the vector of linear combination coefficients $\\left[ \\lambda_1, ..., \\lambda_N \\right]^T$.\r\n\r\nFor a system with N measurement data sites,  $A$ is an NxN-matrix called the **interpolation matrix** or **Vandermonde Matrix** The elements of A are given by the basis functions, $\\psi_j$  evaluated at each data site, $x_i$. \r\n>Elements of $A$: \r\n\\begin{equation*}\r\na_{ij}=\\psi_j(x_i)\r\n\\end{equation*}\r\n\r\nBy using numerical methods and solving this linear system, we will have our interpolation function as a linear combination of our basis functions. \r\n####Familiar Example of Interpolation Basis\r\nA choice of basis functions, $\\psi_i$, which may familiar to undergraduate students is the basis of (N-1)-degree polynomials. If we wish to find a 1-Dimensional interpolation function from N distinct data sites, we can find an (N-1)-degree polynomial which goes exactly through all sites. In other words, by choosing our basis functions to be successive powers of x up to (N-1), we can solve our interpolation system for our function.\r\n> Polynomial Interpolation Basis: \r\n\\begin{equation*}\r\n\\psi_{i=1}^N=\\{1,x,x^2,x^3, ..., x^{N-1}\\}\r\n\\end{equation*}\r\n\r\nAn example of this interpolation with 6 data sites can be seen in the figure below. Here the interpolation function, as a linear combination, is $s(x)=-0.02988 x^5 + 0.417 x^4 - 2.018 x^3 + 3.694 x^2 - 1.722 x - 5.511e^{-14}$\r\n\r\n![enter image description here][8]\r\n\r\nHowever, while polynomial basis is simple for 1-Dimensional interpolation, this method is not ideal for higher dimensions. To accommodate higher dimension interpolation, we must choose our basis differently.\r\n\r\n##Well-Posedness in Higher Dimensional Interpolation\r\nWhen defining our linear system we must consider whether our system is **well-posed**. That is, does there exist a solution to our interpolation problem, and if so is that solution unique? \r\n>Well-Posedness in Linear Systems: Our system will be well-posed if and only if $A$ is non-singular, i.e. $\\det(A)\\neq0$\r\n\r\nFor 1-D interpolation, many choices in basis functions will guarantee a well-posed system. In our example of polynomial interpolation, for instance, it was guaranteed that for N-distinct data sites a unique (N-1)-degree polynomial will interpolate the measurements. So without predetermining any information about our data sites (other than that they are distinct from each other), or their measurements, we can define our basis functions independently of our data and expect a unique, well-posed solution. \r\n\r\nHowever, for n-Dimensions where $n\\geq2$ this is never guaranteed! That is, no matter what we choose for our set of basis functions, there will always be data sites which produce ill-posed systems. The implication of this is that we can not define our basis functions independently of our data and expect a well-posed system. This results from the Haar-Mairhuber-Curtis Theorem.\r\n\r\n###Haar-Mairhuber-Curtis Theorem\r\n![enter image description here][9]\r\n\r\nThrough the work of AlfrÃ©d Haar and his description of **Haar Spaces** we gain the negative result that well-posedness is not guaranteed in higher dimensional linear systems with independently chosen basis functions. To state the theorem we first define Haar spaces.\r\n\r\n>Definition of Haar Space:\r\nLet $\\Omega \\subset \\mathbb{R}^N$ be a set with at least $N$ sites in it. Let $V \\subset C(\\Omega)$ be an $N$-dimensional subspace of continuous functions. Then, we say that $V$ is a **Haar Space** if for any collection of $N$ sites $\\{x_1,...,x_N\\}$ with any corresponding set of values $\\{f_1,...,f_N\\}$, we can find a unique function $s \\in V$ such that $s(x_k)=f_k$.\r\n\r\nFrom this definition we have the following lemma.\r\n>Lemma:\r\nLet $\\Omega \\subset \\mathbb{R}^N$ be a set with at least $N$ sites in it and $V \\subset C(\\Omega)$ be a subspace. \r\nThen, $V$ is an $N$-dimensional Haar Space if and only if for any distinct sites $\\{x_1,...,x_N\\} \\in \\Omega$ and any basis of functions $\\{\\psi_1,...,\\psi_N\\} \\in V$, we have $\\det(\\psi_j(x_i))\\neq0$.\r\n\r\nIn other words:\r\n>$V$ is a Haar Space $\\iff$ any set of basis function produce well-posed system for any set of distinct data sites.\r\n\r\nFor the purposes of interpolation, then, interpolating within a Haar space is ideal, because then we can choose our basis independently of our data and, as per the lemma, we are guaranteed a well-posed system and a unique solution.\r\n\r\nHowever, by the negative result of the Mairhuber-Curtis Theorem, there can be no Haar Spaces in $N$-Dimensions for $N \\geq 2$\r\n>Mairhuber-Curtis Theorem:\r\nLet $\\Omega \\subset \\mathbb{R}^N$, $N \\geq 2$ contain an interior site. Then, there is no Haar space of dimension $N \\geq 2$ for $\\Omega$.\r\n\r\nSo, if we are interpolating scattered data in higher dimensions, by the Haar-Mairhuber-Curtis Theorem we cannot choose our basis functions independent from our data sites. However, this does not mean we cannot interpolate in higher dimensions using our interpolation assumption.\r\n>If we can't guarantee well-posedness with independently chosen basis functions, we must choose our basis functions depending on our data sites. \r\n\r\n##Basis Functions for Higher Dimension Interpolation\r\nOne method for defining basis functions depending on our data sites is to take a single function and translate it for each site. That is, our basis functions will be **translates** of a single function for each data site. \r\n\r\n###Translates of the Basic Function\r\nIf our basis functions are translates of a function, which function should we translate? By answering this question we will arrive at the definition of Radial Basis Functions, but first let's consider a preliminary function: the basic function.\r\n>The Basic Function: \r\n\\begin{equation*}\r\n\\psi_i(x)=||x-x_i||\r\n\\end{equation*}\r\n\r\n\r\nPictured below, the basic function is the absolute valued function given by the Euclidean distance from a **center point** $x_i \\in \\mathbb{R}^N$. The basic function has the feature that it is radially symmetric about this center point. \r\n\r\n![enter image description here][10]\r\n\r\nWe can define our set of basis functions, $\\{\\psi_i(x)\\}_{i=1}^N$, as translates of our basic function such that the center points are located at our data sites. \r\n>Set of Basis Functions: \r\n\\begin{equation*}\r\n\\{\\psi_i(x)=||x-x_i||\\}_{i=1}^N\r\n\\end{equation*}\r\n\r\nIn other words, our set of basis functions is composed of basic functions centered each of our data sites. We can visualize one of these centered basic functions in the figure below.\r\n\r\n![enter image description here][11]\r\n\r\nNow that we have chosen our basis functions, we can look at the linear system which it produces. For instance, our interpolation matrix, $A$, now becomes:\r\n\\begin{equation*}\r\nA=\r\n\\begin{bmatrix}\r\n||x_1-x_1|| & ||x_1-x_2|| & \\cdots & ||x_1-x_N||\\\\\r\n||x_2-x_1|| & ||x_2-x_2||& \\cdots & ||x_2-x_N||\\\\\r\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\r\n||x_N-x_1|| & ||x_N-x_2||& \\cdots & ||x_N-x_N||\r\n\\end{bmatrix}\r\n\\end{equation*}\r\n\r\nThis matrix is known as the **distance matrix** with Euclidean distance. \r\n\r\nBut, if we're not interpolating in 1-D, then we know we're not in a Haar Space. How do we know that our linear interpolation system with the distance matrix is well-posed? \r\n\r\n>Lemma from Linear Algebra: \r\nDistance Matricies with Euclidean distance, for distinct points in $\\mathbb{R}^n$ are always non-singular.\r\n\r\nFrom the above lemma we know that our interpolation matrix is non-singular. Therefore, we know our system is well-posed and that there exists a unique interpolation function! \r\n\r\nHowever, the choice of $\\psi_i(x)=||x-x_i||$ as our basic function is not ideal. As we can see from our above plot of the basic function centered at $x_i$, the first derivative of the basic function is discontinuous at our center point, $x_i$. This has the consequence that, at each of our data sites, the first derivative of our interpolation function will be discontinuous. This is problematic because, ideally, we would like to have a $C^\\infty$ smooth interpolation function so we can use methods from calculus to analyze our function. \r\n\r\nHow can we remedy our derivative discontinuities in our interpolation function?\r\n\r\n###Building a Better Basic Function\r\nIn 1968, R.L. Hardy suggested that by using a $C^\\infty$ smooth function as our basic function, we can produce smooth interpolation functions. These functions are called **Kernels**. The kernel suggested by Hardy was the **Multiquadric Kernel**.\r\n\r\n>Hardy's Multiquadric Kernel:\r\n\\begin{align*}\r\n\\psi(x)=\\sqrt{c^2 + x^2}\r\n\\end{align*}\r\nwhere $c \\neq 0$.\r\n\r\nNotice that if we allow $c=0$ in the multiquadric kernel then we are actually describing the basic function used above. So, in other words, Hardy's multiquadric kernel is like the basic function but smoothed with a parameter $c$. By looking at a plot of the multiquadric kernel, we can see that the discontinuity from the basic function has been addressed. In fact, the multiquadric function is, as desired, $C^\\infty$ smooth.\r\n\r\n![enter image description here][12]\r\n\r\nAs before, we will define our basis functions, $\\{\\psi_i\\}_{i=1}^{N}$, as a set of multiquadric kernels translated such that they are centered at our data sites, $x_i$.\r\n\r\n>Basis of Multiquadric Kernels:\r\n\\begin{equation*}\r\n\\{\\psi_i(x)=\\sqrt{c^2 + (||x-x_i||)^2}\\}_{i=1}^N\r\n\\end{equation*}\r\n\r\nWe can visualize one of these translated multiquadric kernels in the figure below. \r\n\r\n![enter image description here][13]\r\n\r\n###Radial Basis Function Kernels\r\nNotice that the multiquadric kernel is also radially symmetric about its center, $x_i$. Because of this radial symmetry, the multiquadric kernel can be described as a **Radial Basis Function**. In other words, it is a basis function which depends only on the radial distance from its center. Since our basis functions $\\psi_i(x)$ depend only on distance, we can re-express them as such.\r\n>Radial Basis Functions:\r\n\\begin{equation*}\r\n\\psi(||x-x_i||)= \\phi(r)\r\n\\end{equation*}\r\nwhere $r=||x-x_i||$\r\n\r\nWith our interpolation assumption, we can express our interpolation function as a linear combination of these functions, as before:\r\n>Interpolation as Linear Combination of Radial Basis Functions:\r\n\\begin{equation*}\r\ns(x)=\\sum_{i=1}^N \\lambda_i \\psi(||x-x_i||)=\\sum_{i=1}^N \\lambda_i \\phi(r) \r\n\\end{equation*}\r\n\r\nThere are a few commonly used radial basis function kernels:\r\n\r\n - Multiquadric: $\\phi(r)=\\sqrt{1+(\\epsilon r)^2}$![enter image description here][14]\r\n - Inverse Multiquadric: $\\phi(r)=\\frac{1}{\\sqrt{1+(\\epsilon r)^2}}$ ![enter image description here][15]\r\n - Inverse Quadratic: $\\phi(r)=\\frac{1}{1+(\\epsilon r)^2}$ ![enter image description here][16]\r\n - Gaussian:  $\\phi(r)=e^{-(\\epsilon r)^2}$ ![enter image description here][17]\r\n\r\nAs before, we can use translates of these functions centered on our data sites as basis for our interpolation linear system. Further, notice that the multiquadric kernel has been rearranged to replace $c$ with a **shape parameter**, $\\epsilon$ consistent with the other kernels.\r\n\r\nHowever, by using the radial basis kernels as our basis, we change the interpolation matrix so that it is no longer the distance matrix as before.\r\n\r\n>Interpolation matrix with RBF kernels:\r\n\\begin{equation*}\r\nA=\r\n\\begin{bmatrix}\r\n\\phi_1(r_1) & \\phi_1(r_2) & \\cdots & \\phi_1(r_N)\\\\\r\n\\phi_2(r_1) & \\phi_2(r_2)& \\cdots & \\phi_2(r_N)\\\\\r\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\r\n\\phi_N(r_1) & \\phi_N(r_2)& \\cdots & \\phi_N(r_N)\r\n\\end{bmatrix}\r\n\\end{equation*}\r\n\r\nIf $N\\geq2$ then we are still not interpolating in a Haar Space, and since we are no longer using a distance matrix, can we expect well-posedness?\r\n\r\nTo answer this question we determine if our interpolation matrix is **positive-definite**.\r\n>A matrix, $A$, is positive-definite if\r\n\\begin{align*}\r\n& t^TAt>0 & \\forall t=\\left[ t_1, t_2, ..., t_n\\right]\\neq 0 \\in \\mathbb{R}^n\r\n\\end{align*}\r\n\r\nUsing this definition we have the following condition:\r\n>If interpolation matrix, $A$, is symmetric, positive-definite , then $A$ is nonsingular and our system is well-posed.\r\n\r\nSo we can guarantee the existence of a unique solution if we choose our kernels such that $A$ will be positive-definite. In fact, we can produce positive-definite interpolation matrices by using positive-definite kernels.\r\n\r\n>A function, $\\phi: \\mathbb{R}^n\\times \\mathbb{R}^n \\rightarrow \\mathbb{R}$, is said to be positive definite if\r\n:\r\n\\begin{align*}\r\n&\\sum_{i=1}^N \\sum_{j=1}^N \\phi(||x-x_i||)t_i\\bar{t_j}>0 &\\forall t=\\left[ t_1, t_2, ..., t_n\\right]\\neq 0 \\in \\mathbb{C}^n\r\n\\end{align*}\r\n\r\nOf the common RBF kernels described above, all are positive-definite except Hardy's Multiquadric kernel. However, the multiquadric kernel is guaranteed to produce well-posed systems for other, similar reasons (that it is conditionally negative-definite). With the exception of Hardy's multiquadric kernel, by using positive-definite kernels we can produce positive-definite interpolation matrices which guarantee well-posed systems! \r\n\r\nSo, by using Radial Basis Kernels for interpolation, we have shown that there exists a unique interpolation function $s(x)$ which interpolates scattered data in N-dimensions.\r\n>Radial Basis Interpolation\r\n\\begin{equation*}\r\ns(x)=\\sum_{i=1}^N \\lambda_i \\psi(||x-x_i||)=\\sum_{i=1}^N \\lambda_i \\phi(r) \r\n\\end{equation*}\r\n\r\n###Well-posed v.s. Well-conditioned\r\nIn the discussion above we have shown that radial basis interpolation is well-posed, so there exists a unique solution for the interpolation problem. However, because these systems are solved using numerical methods on computers, they are subject to computational limitations. By using computational methods we introduce a complication, just because a solution exists, doesn't mean that it is accessible through numerical methods. A common example of the limitations that can cause a solution to be inaccessible is the accumulation of rounding errors. If our solution exists, and the system behaves 'nicely' with computational solving methods, then we say the solution is **well-conditioned**.\r\n\r\nRadial basis interpolation problems, although well-posed, have the propensity to be very ill-conditioned. This is in part due the choice **shape parameter**, $\\epsilon$. For some systems, small changes in $\\epsilon$ may have potentially significant influences on the system. \r\n\r\nIn the two figures below we can see how increasing the value of epsilon will change the shape of the individual kernel basis functions.\r\n\r\nFor $\\epsilon=0.4$\r\n![enter image description here][18]\r\n\r\nFor $\\epsilon=1$\r\n![enter image description here][19]\r\n\r\nIn the three figures below, we can see how increasing the value of epsilon will cause the interpolation system to become ill-conditioned. Keep in mind that the interpolation solution for each $\\epsilon$ value still exists, but the computation methods create noise and are unable to find the function.\r\n\r\n![enter image description here][20]\r\n\r\n![enter image description here][21]\r\n\r\n![enter image description here][22]\r\n\r\nSo we can see that in order to use radial basis function interpolation we must choose epsilon in such a way that the system does not become ill-conditioned. \r\n\r\nAnother limitation of radial basis function interpolation is that any error that occurs, as with ill-conditioning, occurs to a greater extent near the boundaries. This can be seen in the above three figures as the solution becomes more noisy, the noise is greater at the boundaries. This is because radial basis function interpolation relies on the radial symmetry of the basis functions. Basis functions centered at data sites on or close to the boundaries of the interpolation space become asymmetric. Of course, this can be avoided entirely by using radial basis function interpolation to interpolate functions in spaces without boundaries, e.g. surface of a sphere.\r\n\r\n##Demonstrating Radial Basis Interpolation on Surface of Sphere\r\nAs part of this project I demonstrate how [SciPy's implimentation of Radial Basis Function interpolation][3] can be used to interpolate spherical harmonic functions on the surface of a sphere. The complete code for this demonstration can be found in this repository under the `Interpolation Demonstration` folder in the file [SphericalHarmonicInterpolation.py][5].\r\n\r\n###Dependencies\r\nTo fully use the python code you need the following libraries:\r\n\r\n - [SciPy](http://www.scipy.org/)\r\n - [DiPy](http://nipy.org/dipy/index.html)\r\n - [MayaVi](http://mayavi.sourceforge.net/)\r\n\r\n###Setting Up Coordinates\r\nThere are two sets of points used throughout the code. The data sites, which is used to train the RBF interpolation, called `coarse` coordinates, and the interpolation sites, where the function is being interpolated, called `fine` coordinates. I define the function which produces both set of points\r\n\r\n```python\r\ndef coordinates(n_fine, n_coarse):\r\n```\r\nwhere `n_fine` and `n_coarse` are parameters given to define the resolution of the interpolation space and the number of data sites respectively. Because of the way the interpolation space grid is defined, `n_fine` is given as a complex number.\r\n\r\n####Fine Coordinate Grid\r\nThe interpolation space grid, produced by the function `make_coor(n)` called with `n_fine` produces a grid of points on a sphere corresponding to latitude-longitude style grid points. In other words, the function creates an (n x n)-sized grid of points on the ($\\phi, \\theta$)-space. Then the function converts those points to Cartesian (x,y,z)-coordinates.\r\n```python\r\n    def make_coor(n):\r\n        '''Creates points on the surface of sphere using lat-lon grid points'''\r\n        phi, theta = np.mgrid[0:pi:n, 0:2 * pi:n]\r\n        Coor = namedtuple('Coor', 'r phi theta x y z')\r\n        r = 1\r\n        x = r * sin(phi) * cos(theta)\r\n        y = r * sin(phi) * sin(theta)\r\n        z = r * cos(phi)\r\n        return Coor(r, phi, theta, x, y, z)\r\n```\r\nThe resulting points and spherical mesh can be seen in the figure below for `n_fine = 20j`\r\n\r\n![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/finegrid.png)\r\n\r\nFrom the figure we can see that the `fine` grid produces points at a much higher density at the poles than along the 'equator'. For this reason, we cannot use these points to train our radial basis function. Instead we must use a different method to produce our data sites.\r\n\r\n####Coarse Coordinate (Data Sites) Grid\r\nFor the RBF interpolation of an arbitrary function on the surface of a sphere we want to choose our points so they are equally spaced from each other. As it happens, the problem of uniformly distributing n-many points on the surface of a sphere is an open problem. For a large ($N \\geq 10$) number of points, a sufficient method for pseudo-uniformly distributing $N$ points on the surface of the sphere is the **Golden Section Spiral** method. This algorithm places the points according to the golden spiral and can be visualized in the video below.\r\n\r\n<iframe width=\"480\" height=\"360\" src=\"//www.youtube.com/embed/Ua0kig6N3po?rel=0\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\nThis algorithm was implemented in my code as the following function\r\n\r\n```python\r\n    def uniform_spherical_distribution(N):\r\n        \"\"\"n points distributed evenly on the surface of a unit sphere\"\"\"\r\n        pts = []\r\n        r = 1\r\n        inc = pi * (3 - sqrt(5))\r\n        off = 2 / float(N)\r\n        for k in range(0, int(N)):\r\n            y = k * off - 1 + (off / 2)\r\n            r = sqrt(1 - y * y)\r\n            phi = k * inc\r\n            pts.append([cos(phi) * r, y, sin(phi) * r])\r\n        return np.array(pts)\r\n```\r\nHowever, since this only produces the Cartesian coordinates for these points and we will need the spherical coordinates, a we also append the spherical coordinates using the function:\r\n```python\r\n    def appendSpherical_np(xyz):\r\n        '''Appends spherical coordinates to array of Cartesian coordinates'''\r\n        ptsnew = np.hstack((xyz, np.zeros(xyz.shape)))\r\n        xy = xyz[:, 0] ** 2 + xyz[:, 1] ** 2\r\n        ptsnew[:, 3] = np.sqrt(xy + xyz[:, 2] ** 2)\r\n        # for elevation angle defined from Z-axis down\r\n        ptsnew[:, 4] = np.arctan2(np.sqrt(xy), xyz[:, 2])\r\n        # ptsnew[:,4] = np.arctan2(xyz[:,2], np.sqrt(xy)) # for elevation angle\r\n        # defined from XY-plane up\r\n        ptsnew[:, 5] = np.arctan2(xyz[:, 1], xyz[:, 0])\r\n        return ptsnew\r\n```\r\nwhere parameter  `xyz` is an array of Cartesian coordinates. \r\n\r\nTo produce our uniformly spaced coarse coordinates for interpolation, we call the function\r\n\r\n```python\r\n    def make_uni_coor(n):\r\n        '''Make named tuple of unifromly distrubed points on sphere'''\r\n        Coor = namedtuple('Coor', 'theta phi x y z')\r\n        pts = uniform_spherical_distribution(n)\r\n        pts = appendSpherical_np(pts)\r\n\r\n        return Coor(pts[:, 5], pts[:, 4], pts[:, 0], pts[:, 1], pts[:, 2])\r\n```        \r\nHowever, we've only generated the points of the sphere without providing information on how these points relate to each other. If we wish to plot these points as though they all belong on the surface of the sphere, we need to define a mesh. For this we use Delaunay triangulation to produce triangles between three adjacent points on the sphere. \r\n\r\nTo do this, we use [DiPy's sphere object](http://nipy.sourceforge.net/dipy/reference/dipy.core.sphere.html) which allows us to define a sphere using our Cartesian coordinates. The object has the method `faces()` which are an array of triangles for our Delaunay mesh. \r\n\r\nWe can visualize our pseudo-uniformly distributed points and their Delaunay mesh in the figure below for `n_coarse = 100`\r\n\r\n![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/coarsegrid.png)\r\n\r\n###Using Named Tuples\r\nThe coordinate systems produced above use python's [namedtuples](https://docs.python.org/2/library/collections.html#collections.namedtuple) as a variable naming convention. For instance, when defining our `fine` spherical grid we first define a namedtuple:\r\n\r\n```python\r\nCoor = namedtuple('Coor', 'r phi theta x y z')\r\n```\r\nThen, when the function is returning the coordinates, it stores them as a named tuple as follows:\r\n\r\n```python\r\nreturn Coor(r, phi, theta, x, y, z)\r\n```\r\n\r\nAs such we can address the coordinates by selecting named elements of the tuple. The parent function for the producing the coordinates stores the fine and coarse coordinates as named tuples.\r\n```python\r\ndef coordinates(n_fine, n_coarse):\r\n...\r\n    Coordinates = namedtuple('Coordinates', 'fine coarse ')\r\n\r\n    return Coordinates(make_coor(n_fine), make_uni_coor(n_coarse))\r\n```\r\nNow, if we generate our coordinates by calling this function and naming the output `Coor`.\r\n```python\r\nCoor = coordinates(n_fine, n_coarse):\r\n```\r\nWe can access all our coordinate information by addressing named elements inside the tuple. For instance, if we wish to address the fine coordinate's $\\phi$ component, we can do so as follows `Coor.fine.phi`\r\n\r\nUsing named tuples for variable names allows for flexible and readable python code. \r\n\r\n###Interpolating function\r\nNow that we have our coordinates we can define a function on the surface of the sphere at those coordinates. For an example function on a sphere's surface we use the real part of spherical harmonics. Specifically, we use the real part of spherical harmonic $Y^3_4$. \r\n\r\nTo implement this, we use [SciPy's Spherical Harmonic Function](http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.special.sph_harm.html) and define a function:\r\n\r\n```python\r\ndef harmonic(m, l, coor):\r\n    '''Produce m,l spherical harmonic at coarse and fine coordinates'''\r\n    Harmonic = namedtuple('Harmonic', 'fine coarse')\r\n    return Harmonic(\r\n        special.sph_harm(m, l, coor.fine.theta, coor.fine.phi).real,\r\n        special.sph_harm(m, l, coor.coarse.theta, coor.coarse.phi).real\r\n    )\r\n```\r\nAgain, we make use of the namedtuple to define a fine and coarse harmonic. Since we are using RBF to interpolate the spherical harmonic from the coarse sites, we technically only need to evaluate the harmonic at the coarse coordinates. However, we are also interested in comparing the interpolated result to the actual function, to do this we also find the values of the function at the fine coordinates.\r\n\r\nWe call our function using our `coordinates`\r\n```python\r\nfunction = harmonic(3, 4, coordinates)\r\n```\r\n\r\n###Implementing the Radial Basis Function Interpolation\r\nWe use  [SciPy implementation of RBF interpolation][3] to define a function:\r\n```python\r\ndef rbf_interpolate(coor, coarse_function, epsilon=None):\r\n    '''Radial Basis Function Interpolation from coarse sites to fine cooridnates'''\r\n    # Train the interpolation using interp coordinates\r\n    rbf = Rbf(coor.coarse.x, coor.coarse.y, \r\n              coor.coarse.z, coarse_function, norm=angle, epsilon=epsilon)\r\n    # The result of the interpolation on fine coordinates\r\n    return rbf(coor.fine.x, coor.fine.y, coor.fine.z)\r\n```\r\n\r\nWe call our RBF interpolation using our coarse Cartesian coordinates and the value of the harmonic at those coordinates:\r\n```python\r\n    rbf = Rbf(coor.coarse.x, coor.coarse.y, \r\n              coor.coarse.z, coarse_function, norm=angle, epsilon=epsilon)\r\n```\r\nNotice that can we provide a value for epsilon (if given `None` SciPy will compute a default value). Further, note that we define a `norm`. This is the distance metric used to determine the radial distance from the data sites. As a default, SciPy will use the Euclidean Distance as the distance norm. However, since we are training our function using Cartesian coordinates on the surface of the unit sphere, we must use a distance metric for points on the surface of that sphere. \r\n\r\nFor the $S^2$ distance norm we define a function to be called from our Rbf:\r\n```python\r\ndef angle(x1, x2):\r\n    '''Distance metric on the surface of the unit sphere'''\r\n    xx = np.arccos((x1 * x2).sum(axis=0))\r\n    xx[np.isnan(xx)] = 0\r\n    return xx\r\n```\r\nNow once we train our radial basis function, `rbf()` we can use it to interpolate the spherical harmonic on our fine coordinates:\r\n```python\r\nreturn rbf(coor.fine.x, coor.fine.y, coor.fine.z)\r\n```\r\n###Optimizing our Choice of Epsilon\r\nWe can define errors of our interpolation to be the difference between the interpolated function and the actual spherical harmonic function at each of the fine coordinates. We define a python function to give us these values:\r\n```python\r\ndef interp_error(fine_function, interp_results):\r\n    '''Error between interpolated function and actual function'''\r\n    Error = namedtuple('Error', 'errors max')\r\n    errors = fine_function - interp_results\r\n    error_max = np.max(np.abs(errors))\r\n    return Error(errors, error_max)\r\n```\r\n\r\nFurther, we can assess the overall error of the interpolation by using the maximum difference between the interpolation and the function and calling this value `error_max`. \r\n\r\nIf we preform multiple RBF interpolation, each with different values of the shape parameter, $\\epsilon$, we can see how `epsilon` effects the maximum error of the interpolation. Further, we can use this to choose the epsilon which minimizes this error.\r\n\r\nI plot the maximum error for increasing values of epsilon, colouring the optimal choice red. \r\n\r\n![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/optimizationcurve.png)\r\n\r\nBy RBF interpolating our function with the optimal value of epsilon, we can minimize the interpolation error.\r\n\r\n###Visualizing the Results of the Interpolation\r\nUsing the [MayaVi scientific data visualization library](http://mayavi.sourceforge.net/) we can visualize the results of this interpolation.\r\n\r\n>Note: The following images are stills from the MayaVi visualization environment, which is interactive. I highly recommend downloading and playing with these figures yourself, as you can rotate around the sphere.\r\n\r\nFirst, we plot the spherical harmonic function on the sphere. We also add small 'warts' which indicate where the data sites being used for interpolation are, coloured to the value of the function at those sites.\r\n\r\n```python\r\n mlab.figure()\r\n    vmax, vmin = np.max(fun.fine), np.min(fun.fine)\r\n    mlab.mesh(coor.fine.x, coor.fine.y, coor.fine.z,\r\n              scalars=fun.fine, vmax=vmax, vmin=vmin)\r\n    mlab.points3d(coor.coarse.x, coor.coarse.y, coor.coarse.z, fun.coarse,\r\n                  scale_factor=0.1, scale_mode='none', vmax=vmax, vmin=vmin)\r\n    mlab.colorbar(title='Spherical Harmonic', orientation='vertical')\r\n    mlab.savefig('Figures/functionsphere.png')\r\n```\r\n\r\n![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/functionsphere.png)\r\n \r\n Then, we can see the interpolated function:\r\n \r\n ![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/interpsphere.png)\r\n \r\nFinally, we can see where the error occurs on our sphere by visualizing the error:\r\n\r\n![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/errorsphere.png)\r\n\r\nNote that the above interpolation uses a relatively high number of data sites (N=350). We can see how this interpolation worsens with a fewer number of sites (N=100).\r\n\r\nAgain, here is the spherical harmonic we are interpolating with the 100 data sites. \r\n\r\n![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/poorfunctionsphere.png)\r\n \r\nHere is the interpolation trained with fewer sites.\r\n \r\n ![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/poorinterpsphere.png)\r\n\r\nPredictably, this causes the error of the interpolation to increase.\r\n\r\n![enter image description here](https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/Figures/poorerrorsphere.png)\r\n\r\n\r\n###Conclusion\r\nRadial Basis Interpolation is an effective method to interpolate high dimensional scattered data, especially if the interpolation space has no boundaries.\r\n\r\n\r\n###Recommended Reading for Radial Basis Interpolation\r\nBuhmann, M., 2003. Radial basis functions: theory and implementations 5th ed., Cambridge University Press.\r\n\r\nFasshauer, G., 2012. Mesh Free Methods (590). Available at: http://www.math.iit.edu/~fass/590/notes/ [Accessed June 19, 2014].\r\n\r\nMongillo, M., 2011. Choosing Basis Functions and Shape Parameters for Radial Basis Function Methods, Available at: http://www.siam.org/students/siuro/vol4/S01084.pdf [Accessed July 2, 2014].\r\n\r\nWright, G., 2003. Radial Basis Function Interpolation: Numerical and Analytical Developments. University of Colorado. Available at: http://amath.colorado.edu/faculty/fornberg/Docs/GradyWrightThesis.pdf [Accessed May 14, 2014].\r\n\r\n\r\n  [1]: http://cumc.math.ca/2014/\r\n  [2]: https://raw.githubusercontent.com/jessebett/USRA/tree/master/CUMC%20Presentation\r\n  [3]: http://scipy.org/docs/scipy/reference/generated/scipy.interpolate.Rbf.html#scipy.interpolate.Rbf\r\n  [4]: https://raw.githubusercontent.com/jessebett/USRA/tree/master/Interpolation%20Demonstration\r\n  [5]: https://raw.githubusercontent.com/jessebett/USRA/master/Interpolation%20Demonstration/SphericalHarmonicInterpolation.py\r\n  [6]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/interpdef.png\r\n  [7]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/interpvsapprox.png\r\n  [8]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/polyinterp.png\r\n  [9]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/HMC.png\r\n  [10]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/basicfunxi.png\r\n  [11]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/basicbasis.png\r\n  [12]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/kernelfun.png\r\n  [13]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/kernelbasis.png\r\n  [14]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/multiquadric.png\r\n  [15]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/inversemultiquadric.png\r\n  [16]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/inversequadratic.png\r\n  [17]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/gaussian.png\r\n  [18]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/basisgaus1.png\r\n  [19]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/basisgaus2.png\r\n  [20]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/conditioned.png\r\n  [21]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/illconditioned.png\r\n  [22]: https://raw.githubusercontent.com/jessebett/USRA/master/CUMC%20Presentation/Figures/veryillconditioned.png","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}